3.	Создание игры Space.


3.1.   Давай напишем новую компьютерную игрушку.
У нас будет космический корабль, который стреляет ракетами в НЛО.
А НЛО в свою очередь сбрасывает на корабль бомбы.
Ну и, конечно, всё дело происходит в космосе.
Нам понадобятся классы: Space(космос), SpaceShip(космический корабль) и Ufo(НЛО).
Создай классы: Space, SpaceShip, Ufo.
Добавь метод main в класс Space.


Требования:
 
• Создай в отдельном файле класс Space.
 
• Создай в отдельном файле класс SpaceShip.
 
• Создай в отдельном файле класс Ufo.
 
• Добавь метод main в класс Space.



3.2.   У нас будут бомбы и ракеты.
Значит нам нужны классы Bomb(бомба) и Rocket(ракета).
Создай их.
У наших объектов будет много общего.
Они будут перемещаться по космосу и отрисовываться.
Значит у них у всех будут координаты и размер.
А еще методы move() - для перемещения и draw() для отрисовки.
Есть интересное предложение: давай введем один базовый класс для всех объектов.
Пусть это будет класс BaseObject.
А классы Ufo, SpaceShip, Rocket, Bomb от него наследуются.
Создай абстрактный класс BaseObject и добавь его родителем к классам Ufo, SpaceShip, Rocket, Bomb.
Еще нам понадобится класс Canvas.
Он будет ответственным за "отрисовку" объектов.
С его помощью они будут отрисовывать себя.
Вернее даже на нем.
Создай и этот класс.


Требования:
 
• Создай в отдельном файле класс Bomb.
 
• Создай в отдельном файле класс Rocket.
 
• Создай в отдельном файле абстрактный класс BaseObject.
 
• Классы Ufo, SpaceShip, Rocket, Bomb должны наследоваться от BaseObject.
 
• Создай в отдельном файле класс Canvas.



3.3.   Для чего нам нужен класс Space?
Чтобы хранить в себе все объекты и управлять их взаимодействием.
А какие параметры должны у него быть?
width (ширина), height (высота). Тип int.
А еще?
а) SpaceShip ship (космический корабль),
б) список для хранения всех НЛО - ufos (List<Ufo>),
в) список для хранения всех ракет - rockets (List<Rocket>),
г) список для хранения всех бомб - bombs (List<Bomb>).
Задание:
Добавь все эти поля в класс Space. Поля должны быть приватными.
Инициализируй коллекции.
И не забудь добавить полям getter'ы, а для ship еще и setter!
Ну и конструктор. А что должен содержать конструктор?
Достаточно будет width и height.


Требования:
 
• В классе Space создай поле width. Добавь для него getter.
 
• В классе Space создай поле height. Добавь для него getter.
 
• В классе Space создай поле ship. Добавь для него getter и setter.
 
• В классе Space создай поле ufos. Добавь для него getter.
 
• В классе Space создай поле rockets. Добавь для него getter.
 
• В классе Space создай поле bombs. Добавь для него getter.
 
• В классе Space создай конструктор, который будет инициализировать width и height.
 
• Инициализируй поля с коллекциями.




3.4.   Чего не хватает классу Space?
Правильно - методов run() и draw().
run управляет всей логикой игры, если ты помнишь.
А draw отвечает за отрисовку очередного "кадра".
А еще нам пригодится метод sleep(int ms).
Создай их.


Требования:
 
• В классе Space создай публичный void метод run().
 
• В классе Space создай публичный void метод draw().
 
• В классе Space создай публичный void метод sleep(int ms).



3.5.   Теперь перейдем к классу BaseObject.
Я хочу сделать несколько предложений.
Во-первых. Для простоты, считать все объекты у нас в космосе круглыми.
Нет, отрисовывать их мы будем фигурными, как и раньше.
А вот при расчетах их взаимодействия исходить из того, что они круглые.
Так - гораздо проще.
Во-вторых. Пусть координаты объектов и радиус будут вещественными числами.
Это придаст плавность движениям и точность всем вычислениям.
А при отрисовке мы будем их округлять.
В классе BaseObject необходимо:
а) Добавить переменные x (double), y (double), radius (double), геттеры и сеттеры для них.
б) Добавить логическую переменную isAlive (жив объект или уже нет).
в) Добавить геттер (isAlive()-метод для isAlive-переменной).
г) Добавить конструктор BaseObject(double x, double y, double radius).
д) Проследить, чтобы в конструкторе isAlive устанавливался в true (мертворожденные нам ни к чему).
Также надо пройтись по всем классам-наследникам и поправить у них конструкторы.
Если ты используешь Intellij IDEA - Alt+Insert тебе в помощь.


Требования:
 
• В классе BaseObject создай поле x (double). Добавь для него getter и setter.
 
• В классе BaseObject создай поле y (double). Добавь для него getter и setter.
 
• В классе BaseObject создай поле radius (double). Добавь для него getter и setter.
 
• В классе BaseObject создай поле isAlive (boolean). Добавь для него getter.
 
• В классе BaseObject создай конструктор BaseObject(double x, double y, double radius). Поле isAlive должно устанавливаться в true.
 
• Создай аналогичные конструкторы во всех классах, которые наследуются от BaseObject.



3.6.   Space (6)
•	Проверка
•	Помощь


•	
Обсуждение
•	Запуск
•	Анализ кода
Условие
Дерево классов
Но и это еще не все.
Классу BaseObject нужны еще методы.
Пока это будут пустые методы draw() и move().
Классы-наследники должны будут переопределить их у себя и реализовать необходимую функциональность.
Еще добавь метод die() - объект умирает (isAlive=false)
А еще нам нужно будет определять попала бомба в корабль или ракета в НЛО.
Это будем делать так:
Создадим специальный метод: public boolean isIntersect(BaseObject o)
Он будет определять - "пересеклись" объекты или нет. Если пересеклись - возвращать true, если нет - false.
Т.к. объекты мы условно считаем кругами, то предлагаю такую формулу взаимодействия:
eсли центр круга одного объекта попал в круг другого, то будем считать, что они столкнулись.
Или еще проще:
дистанция_между_объектами < max (радиус_первого_объекта, радиус_второго_объекта).


Требования:
 
• В классе BaseObject создай пустой публичный void метод draw().
 
• В классе BaseObject создай пустой публичный void метод move().
 
• В классе BaseObject создай публичный void метод die(), который присваивает полю isAlive значение false.
 
• В классе BaseObject создай публичный метод isIntersect(BaseObject o), который возвращает boolean.
 
• Реализуй метод isIntersect(BaseObject o). В случае если объекты столкнулись, нужно вернуть true, иначе - false.




3.7.   Теперь займемся классом Canvas.
Он у нас будет содержать матрицу, куда мы будем рисовать.
У матрицы есть ширина и высота.
А еще будем в ней хранить не числа (int), а символы (char).
В классе Canvas необходимо:
а) Добавить две переменные width и height;
б) Добавить переменную matrix (char[][]);
в) Добавить геттеры для них;
г) В конструкторе проинициализировать матрицу.


Требования:
 
• В классе Canvas создай приватное int поле width. Добавь для него getter.
 
• В классе Canvas создай приватное int поле height. Добавь для него getter.
 
• В классе Canvas создай приватное поле matrix (char[][]). Добавь для него getter.
 
• В классе Canvas создай конструктор Canvas(int width, int height). Инициализируй поля width и height.
 
• Инициализируй в конструкторе поле matrix (char[height][width]).




3.8.   Что мы будем делать с Canvas?
Мы будем рисовать на нем (в его матрице).
Поэтому нам понадобятся два метода:
public void setPoint(double x, double y, char c),
public void drawMatrix(double x, double y, int[][] matrix, char c).
Первый метод - setPoint будет "ставить точку в координатах x,y цветом c".
В методе нужно:
а) математически округлить x и y до целых чисел,
б) занести в matrix[y][x] значение с, если x и y находятся в пределах матрицы (0<=x<matrix[0].length и 0<=y<matrix.length).
Второй метод - drawMatrix копирует переданную ему картинку (матрицу) в матрицу Canvas.
И не просто копирует, а начиная с координат x, y.
В методе нужно:
а) с помощью двух вложенных циклов пройтись по всем ячейкам переданной картинки,
б) если значение ячейки matrix[i][j] не равно 0, то покрасить в матрице объекта Canvas точку (x+j, y+i) в цвет c:
setPoint(x+j, y+i, c)


Требования:
 
• В классе Canvas создай метод public void setPoint(double x, double y, char c).
 
• Метод setPoint должен заносить в матрицу по координатам x, y символ с.
 
• В классе Canvas создай метод public void drawMatrix(double x, double y, int[][] matrix, char c).
 
• Метод drawMatrix, начиная с координат x, y, должен заполнять полотно символами с, согласно переданной в метод матрицей matrix.




3.9.   Еще Canvas понадобится два метода, напиши их.
а) метод public void clear();
Этот метод будет очищать матрицу, чтобы на ней снова можно было рисовать.
В методе нужно заменить все символы матрицы на пробелы.
б) метод public void print();
Этот метод отрисовывает матрицу на экран.
Тут уже ты должен сам разобраться: вывести набор символов не так уж и сложно.
Не забудь добавить пару пустых строк в конце, чтобы матрицы выведенные в разное время не слипались.


Требования:
 
• В классе Canvas создай метод clear().
 
• Метод clear() должен очищать матрицу.
 
• В классе Canvas создай метод print().
 
• Метод print() должен отрисовыть матрицу в консоль.



3.10.   Теперь напишем класс Bomb. Тут все просто.
Bomb унаследован от BaseObject.
Нужно:
а) изменить конструктор:
Конструктор Bomb должен выглядеть примерно так:
public Bomb(double x, double y)
{
super(x, y, 1);
}
x и y переданные в конструктор Bomb мы передаем дальше в конструктор BaseObject с помощью super, где так же указываем радиус "бомбы" равный 1.
б) написать метод public void move():
Тут все просто - бомба падает вниз - просто увеличиваем y на 1.
в) написать метод public void draw(Canvas canvas):
Тут тоже не очень сложная логика. Давай просто ставить точку с координатами (x,y) и "цветом" B:
canvas.setPoint(x,y,'B').
Создай в классе Space нашу игру public static Space game.


Требования:
 
• В классе Bomb конструктор должен принимать координаты, а радиус выставлять всегда равным 1.
 
• В классе Bomb напиши метод move(), который увеличивает координату y на единицу.
 
• В классе Bomb напиши метод draw(Canvas canvas), который для canvas будет ставить символ 'B' в координатах x, y.
 
• В классе Space создай поле public static Space game.




3.11.   Теперь напишем класс Rocket.
Практически совпадает с классом Bomb.
Только:
а) Ракета летит вверх (т.е. y уменьшается на 1);
б) Рисуем не букву "B", а букву "R".


Требования:
 
• В классе Rocket конструктор должен принимать координаты, а радиус выставлять всегда равным 1.
 
• В классе Rocket напиши метод move(), который уменьшает координату y на единицу.
 
• В классе Rocket напиши метод draw(Canvas canvas), который для canvas будет ставить символ 'R' в координатах x, y.



3.12.   Теперь займемся кораблем.
Для сложности сделаем так: если пользователь нажал кнопку влево, то корабль начинает все время двигаться влево.
Если нажал кнопку вправо - все время вправо до упора.
Поэтому заведем специальную переменную dx, которая будет хранить направление движения корабля.
если dx = 1, корабль каждый ход идет на 1 вправо,
если dx = -1, корабль каждый ход идет на 1 влево.
Нужно:
а) добавить конструктор, можно такой:
Радиус корабля будет равен 3. Корабль большой - это вам не ракета и не бомба.
public SpaceShip(double x, double y)
{
super(x, y, 3);
}
б) добавить в класс SpaceShip приватное поле dx (double, по умолчанию равна 0);
в) написать метод public void moveLeft(), который устанавливает поле dx равным -1;
г) написать метод public void moveRight(), который устанавливает поле dx равным 1.


Требования:
 
• В классе SpaceShip конструктор должен принимать координаты x и y, а радиус выставлять всегда равный 3.
 
• В классе SpaceShip добавь поле dx (double).
 
• В классе SpaceShip напиши метод moveLeft(), который устанавливает поле dx равным -1.
 
• В классе SpaceShip напиши метод moveRight(), который устанавливает поле dx равным 1.



3.13.   Теперь перейдем к методам draw, move.
В методе public void move() нужно:
а) увеличить x на dx;
б) проверить, не вылез ли корабль за границы космоса [0, Space.game.getWidth(), ...]. Используй метод checkBorders.
Метод public void draw(Canvas canvas) я напишу сам - просто объяви пустой метод.
Еще нам понадобится метод public void fire(), ведь корабль умеет стрелять.
Этот метод вызывается, когда надо произвести выстрел.
В этом методе нужно:
а) создать две ракеты;
б) установить им координаты левого края корабля и правого края корабля (пушки находятся на расстоянии 2 от центра корабля);
в) добавить эти ракеты в список ракет объекта game. Его можно получить так: Space.game.getRockets()


Требования:
 
• В классе SpaceShip напиши метод move(), который увеличивает поле x на значение dx и проверяет, не вылез ли корабль за границы космоса.
 
• В классе SpaceShip добавь пустой метод draw(Canvas canvas).
 
• В классе SpaceShip напиши метод fire(), который создает две ракеты с координатами левого и правого края корабля и добавляет их в поле rockets у объекта game.



3.14.   Теперь напиши класс Ufo.
Он чуть сложнее класса Bomb и проще SpaceShip.
Тебе понадобятся методы public void draw(Canvas canvas), public void move(), public void fire().
Также не забудь о конструкторе. Типы параметров double, а радиус ufo будет равен 3.
Метод draw() сделай по аналогии с SpaceShip. Рисовать UFO будем символом 'U'.
И добавь матрицу, по аналогии с SpaceShip.
Метод move() надо сделать так:
а) UFO перемещается по случайной траектории (не забудь о проверке границ);
Подсказка:
double dx = Math.random() * 2 - 1; //-1..1
double dy = Math.random() * 2 - 1; //-1..1
б) UFO не опускается в нижнюю половину экрана;
y <= height/2
в) С вероятностью 10% UFO должен стрелять - вызывать метод fire.
Метод fire():
UFO сбрасывает одну бомбу посередине.
Сделать аналогично классу SpaceShip.


Требования:
 
• В классе Ufo конструктор должен принимать координаты x и y, а радиус выставлять всегда равным 3.
 
• В классе Ufo добавь поле с матрицей объекта по аналогии с классом SpaceShip.
 
• В классе Ufo напиши метод draw(), который должен отрисовывать объект по аналогии с классом SpaceShip.
 
• В классе Ufo напиши метод move(), который изменяет координаты объекта согласно заданию.
 
• В классе Ufo напиши метод fire(), который создает бомбу под объектом посередине и добавляет ее в список Space.bombs.
 
• В классе Ufo в методе move() добавь вызов метода fire() c вероятностью 10%.



3.15.   Нужно еще закончить класс Space.
Напиши код метода getAllItems:
Метод должен возвращать один общий список всех объектов типа BaseObject.
Напиши код метода moveAllItems:
Метод должен двигать все объекты по одному разу.
Нужно:
а) получить список всех объектов типа BaseObject;
б) вызвать у каждого из них метод move().


Требования:
 
• В классе Space реализуй метод getAllItems(). Он должен возвращать список всех объектов типа BaseObject, которые сохранены в полях Space.
 
• В классе Space реализуй метод moveAllItems(). Он должен вызывать move() у всех объектов типа BaseObject, которые сохранены в полях Space.



3.16.   И еще немного.
Напиши код метода createUfo():
- если список НЛО пуст - создай один корабль в центре сверху.
Напиши код метода checkBombs():
- нужно проверить не пересеклись ли между собой какая-нибудь бомба и корабль;
- если пересеклись - корабль и бомба умирают: die();
- если бомба упала за границу экрана y > height, бомба тоже умирает.
Напиши код метода checkRockets():
- нужно проверить не пересеклись ли между собой какая-нибудь ракета и НЛО;
- если пересеклись - ракета и НЛО умирают: die();
- если ракета улетела за границу экрана y < 0, ракета тоже умирает.
Напиши код метода removeDead():
- удали из списков ufos, rockets, bombs все мертвые объекты (isAlive() == false).


Требования:
 
• В классе Space реализуй метод createUfo() согласно описанию в задании.
 
• В классе Space реализуй метод checkBombs() согласно описанию в задании.
 
• В классе Space реализуй метод checkRockets() согласно описанию в задании.
 
• В классе Space реализуй метод removeDead() согласно описанию в задании.



3.17.   Надо закончить метод draw().
Поступим по аналогии с методом move() - сегодня я напишу его сам.


Требования:
 
• Перейди на следующий этап задачи.



3.18.   Поставь width & height побольше и можно играть!
Наслаждайся игрой :)


Требования:
 
• Расслабься и получай удовольствие.
